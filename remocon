#!/usr/bin/env bash
# remocon -- run given command remotely, replicating local git work tree on a remote host, and downloading remote changes if needed
#
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2018-03-08
##
#   Copyright 2018 Jaeho Shin
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
##
set -euo pipefail

: ${verbose:=false}
: ${remote_tmux:=true}
: ${remote:=localhost} # defaults to not running things remotely


error()   { echo >&2 "📡 ‼️ " "$@"; false; }
warning() { echo >&2 "📡 ⚠️ " "$@"; }
info()    { echo >&2 "📡" "$@"; }

in_full_tty() { [[ -t 0 && -t 1 && -t 2 ]]; }

################################################################################

# a nimble/simple way to use bash -x itself to get single-quoted escapes instead of backslashes given by printf %q
@q() {
    if [[ $# -eq 0 ]]; then  # quote each line in stdin
        sed "s/'/'\\\\''/g; s/^/'/; s/\$/'/"
    else
        local e
        e=$(PS4= bash --norc -xc ': "$@"' -- "$@" 2>&1)
        echo "${e:2}"
    fi
}
# a handy way to compose a shell script that consists of multiple commands in one shot
cmdseq() {
    : ${cmdsep:="; "}
    local cmd sep=
    for cmd; do
        [[ -n $cmd ]] || continue
        printf "$sep%s" "$cmd"
        sep=$cmdsep
    done
}
# a handy way to show what command is running
x() {
    (
        case ${1:-} in (builtin|command) shift;; esac
        echo "$PS4$(@q "$@")"
    ) >&2
    "$@"
}
$verbose || {
    x() { "$@"; }
    alias x=''
}

mkdelegate() {
    : echo 'generates an executable file for delegating with extra options'
    : echo
    : echo 'mkdelegate FILE ABS_PATH_TO_COMMAND [OPTION...]'
    local file=$1; shift
    mkdir -p "$(dirname "$file")"
    local script=$(
        echo '#!/bin/sh'
        echo "$(@q exec "$@")" '"$@"'
    )
    diff -q <(echo "$script") "$file" &>/dev/null || echo "$script" >"$file"
    chmod +x "$file"
}

# remote bash call -- run on given remote host:workdir given bash function, sending variable and function declarations
ssh_opts=(
)
bash_opts=(
    bash
)
declarationsFor() {
    while [[ $# -gt 0 ]]; do
        if declare -F "$1" &>/dev/null; then
            declare -f -- "$1"
        else
            case $1 in (*=*) declare -- "$1"; v=${1%%=*} ;; (*) v=$1 ;; esac
            declare -p -- "$v"
            # TODO support when fn is neither a variable nor a function (probably a command)
        fi
        shift
    done
}
rbc() {
    local hostworkdir=$1; shift
    local fn=$1; shift
    case $hostworkdir in
        (*:*) host=${hostworkdir%%:*} workdir=${hostworkdir#*:};;
        (*) error "$hostworkdir: HOST[:PATH] required";;
    esac
    # prepare command sequence from given function, variable names
    set -- x @q rbc "$@" "$fn"  # adding some core names to include
    set -- \
        "set -eu" \
        "mkdir -p $(@q "$workdir")" \
        "cd $(@q "$workdir")" \
        "PS4=$(@q "+ $hostworkdir$ ")" \
        "$(declarationsFor "$@")" \
        "$fn"
    # determine how to run the function
    if in_full_tty; then
        # when stdin/out/err is a fully functional terminal
        ssh_opts+=(-t)   # ask ssh for tty
        bash_opts+=(-i)  # ask bash for an interactive shell
    fi
    set -- "${bash_opts[@]}" -c "$(cmdseq "$@")"
    case $host in
        localhost)  # special case: run it directly if on same host
            "$@"
            ;;
        *)  # send it over to remote via ssh by default
            ssh "$host" "${ssh_opts[@]:---}" "$(@q "$@")"
            ;;
    esac
}

# how to duplicate one git worktree to another
# Origin: https://github.com/netj/bpm/blob/master/plugin/git-helper
remocon.dup() {
    (
    set -euo pipefail
    hostpath=$1; shift
    # TODO src_hostpath and dst_hostpath
    case $hostpath in
        (*:*) host=${hostpath%%:*} dir=${hostpath#*:};;
        (*) error "$hostpath: HOST[:PATH] required";;
    esac
    commit=$(git rev-parse HEAD)
    branch=$(git symbolic-ref --short HEAD)
    x git remote add remocon/remote "$host:$dir" 2>/dev/null ||
        x git remote set-url remocon/remote "$host:$dir"
    # TODO pull if dst is localhost
    x git push -q -f remocon/remote HEAD:"$branch" 2>/dev/null || {
        _remocon_git_init() {
            # set -x
            [[ -e .git ]] || x git init
            # lift some git config to allow push
            x git config receive.denyCurrentBranch ignore
        }
        rbc "$hostpath" _remocon_git_init
        x git push -f remocon/remote HEAD:"$branch"
    }
    # TODO transfer git config to destination
    git remote remove remocon/remote
    # bring destination to the current commit
    _actually_rm_files_deleted_from_git_index_that_come_from() {
        local commit=$1; shift
        eval "set -- $(comm -12 <(git ls-tree -r --name-only "$commit" | sort) <(git ls-files --others --exclude-standard | sort) | @q)"
        [[ $# -eq 0 ]] || x rm -f "$@"
    }
    local patch=.git/tethered.patch
    _remocon_reset_to_HEAD() {
        # reverse any previous patch for tethering
        if [[ -s "$patch" ]]; then
            x git apply --binary -R "$patch" || x git stash
            x mv -f "$patch"{,~}
        fi
        if git rev-parse HEAD &>/dev/null; then
            # preserve any outstanding/untethered changes
            git diff --quiet --exit-code HEAD -- || x git stash
            # make sure we're on the tethered branch and commit
            [[ $(git symbolic-ref --short HEAD) = $branch ]] || x git checkout -f $branch --
        else
            # no branch was checked out before
            x git checkout -f $branch --
        fi
        x git reset --hard $commit
        _actually_rm_files_deleted_from_git_index_that_come_from HEAD@{1}  # (necessary as git-reset does not always handle delete files cleanly)
    }
    rbc "$hostpath" _remocon_reset_to_HEAD branch commit patch _actually_rm_files_deleted_from_git_index_that_come_from
    # send staged and unstaged changes
    _remocon_write_patch() { tee "$patch" >/dev/null; }
    x git diff --full-index --binary HEAD | rbc "$hostpath" _remocon_write_patch patch
    _remocon_apply_patch() {
        # with the same outstanding changes on top of the current commit
        ! [[ -s "$patch" ]] || x git apply --binary --apply --stat --cached "$patch"
        # (relying on git-checkout from current git index takes care of a lot, such as permissions, symlinks)
        x git checkout --quiet .
        # (however, git-checkout does not handle deleted files nicely, so ensuring any files in HEAD that fell into --others are removed)
        _actually_rm_files_deleted_from_git_index_that_come_from HEAD
    }
    rbc "$hostpath" _remocon_apply_patch patch _actually_rm_files_deleted_from_git_index_that_come_from
    # replicate staged changes AKA .git/index
    x git diff --full-index --binary --cached | rbc "$hostpath" _remocon_write_patch patch=.git/tethered-index.patch
    _remocon_apply_patch_index() {
        x git reset --quiet  # (resetting the git index first to apply the patch for locally staged changes)
        ! [[ -s "$patch" ]] || x git apply --binary --apply --cached "$patch"
    }
    rbc "$hostpath" _remocon_apply_patch_index patch=.git/tethered-index.patch
    )
}

################################################################################
# common prep

remocon._init() {
    remocon._parse_config
    remocon._setup_ssh_booster
    # break the ssh connection when interrupted, e.g., ControlPath can get stale
    trap 'x ssh "$remote_host" -O stop' INT
} </dev/null >/dev/null

remocon._parse_config() {
    {
    # make sure we're in a git work tree
    $(git rev-parse --is-inside-work-tree) ||
        error "$PWD: Not inside a git work tree"

    # TODO migrate remocon.conf to git config
    # find closest .remocon.conf
    local conf
    conf=$(
        until [[ $PWD = / || -e .remocon.conf ]]; do cd ..; done
        ! [[ -e .remocon.conf ]] || echo "$PWD"/.remocon.conf
    )

    # load from .remocon.conf but let what's in environ override
    ! declare -p remote &>/dev/null || local remote_override=$remote
    ! [[ -e "$conf" ]] || source "$conf"
    ! declare -p remote_override &>/dev/null || remote=$remote_override
    # TODO let all remote_* vars to be overriddable by env vars, e.g., remote_tmux

    # require remote= to be set
    [[ -n ${remote:=} || ${1:-} = set ]] || error "No remote configured. Please run: remocon set"

    # parse remote
    local remote_repo_root
    remote_host="${remote%%:*}"
    remote_repo_root=${remote#$remote_host}
    remote_repo_root=${remote_repo_root#:}

    # use local git work tree's basename and keep it under given remote_repo_root dir
    remote_repo=${remote_repo_root:+$remote_repo_root/}$(basename "$(git rev-parse --show-toplevel)")

    # determine remote workdir based on where in the git repo we're in
    local local_path_to_git_top local_path_within_git
    local_path_to_git_top=$(git rev-parse --show-toplevel)
    PS4="+ localhost:${local_path_to_git_top#$HOME/}\$ "  # to let `x` show more informative lines to stderr
    local_path_within_git=$(git rev-parse --show-prefix)
    remote_workdir="${remote_repo}/${local_path_within_git#/}"
    } >&2

    local v
    for v in remote{,_{host,repo,workdir}}
    do @q "$v=${!v}"
    done
} </dev/null

remocon._setup_ssh_booster() {
    {
    # override ssh options/config
    local sshBoosterOpts
    sshBoosterOpts=(
        # share an ssh connection across invocation
        -o ControlMaster=auto
        -o ControlPath="/tmp/remocon-$USER.sock-%r@%h:%p"
        -o ControlPersist=600
        # forward agent
        -A
    )
    local sshBoosterRoot=~/.cache/remocon/ssh
    local cmd
    for cmd in scp ssh; do
        mkdelegate "$sshBoosterRoot"/bin/"$cmd" "$(type -p "$cmd")" "${sshBoosterOpts[@]}"
    done
    } >&2

    echo 'export PATH='"$(@q "$sshBoosterRoot"/bin)"':"$PATH"'
} </dev/null


################################################################################
# sub-commands

# prints configured remote, inferred remote_repo root, remote_workdir
remocon.remote() { echo "$remote"; }
remocon.remote_repo() { echo "$remote_host:$remote_repo"; }
remocon.remote_workdir() { echo "$remote_host:$remote_workdir"; }

# set up ~/.remocon.conf
remocon.set() {
    local examples=$(echo \
        $'\n'"    user@example.org:tmp/repos       to put a clone of local git work tree 'foo' under 'tmp/repos/foo', or" \
        $'\n'"    example.org or user@example.org  to put all remote clones on the home dir." \
        #
    )
    if [[ $# -eq 0 ]] && in_full_tty; then
        info "Enter a remote host and path prefix to use, e.g.:$examples"
        read -p '>>> ' -r remote || true
    else
        [[ $# -gt 0 ]] || error "No USER@HOST[:PATH] specified as first argument, e.g.:$examples"
        local remote=$1; shift
    fi
    [[ -n $remote ]] || error "No remote specified"
    info "⚙️ [$remote] setting ~/.remocon.conf"
    printf >>~/.remocon.conf 'remote=%q\n' "$remote"
}

# tether remote git repo to local one
remocon.put() {
    [[ $# -eq 0 ]] || error "Cannot put partial changes under given paths: $(@q "$@")"
    # TODO accept multiple remotes as args
    info "⏫ [$remote_host:$remote_repo/] putting a replica of local git work tree on remote"
    remocon.dup "$remote_host:$remote_repo"
    # TODO remocon.dup $local_hostrepo $remote_hostrepo
} </dev/null >&2

# put and run given command on remote from the same workdir relative to the git top-level (AKA git prefix)
remocon.run() {
    remocon.put

    [[ $# -gt 0 ]] || set -- bash -il
    info "▶️ [$remote_host:$remote_workdir] running command: $(@q "$@")"

    eval "_remocon_run_cmd() { x $(@q "$@"); }"
    rbc "$remote_host:$remote_workdir" _remocon_run_cmd
}

# get remote changes back to local
remocon.get() {
    [[ $# -gt 0 ]] || set -- .
    info "⏬ [$remote_host:$remote_workdir] getting remote files under $# paths: $(@q "$@")"
    # TODO remocon.dup $remote_hostrepo $local_hostrepo
    # TODO use git in case rsync is not available?
    x rsync \
        --archive \
        --hard-links \
        --omit-dir-times \
        --checksum \
        --copy-unsafe-links \
        --exclude=.git \
        --partial \
        $(! $verbose || echo '--progress --verbose') \
        --relative --rsync-path="$(printf 'cd; mkdir -p %q && cd %q &>/dev/null && rsync' "$remote_workdir" "$remote_workdir")" \
        "$remote_host":"$(@q "$@")" .
} </dev/null >&2

# programming round-trip mode (put-run-get)
remocon.prg() {
    # find which paths to get from given args
    # (NOTE path list can be terminated by a double-dash `--` to delinate the command to run)
    local pathsToPull=
    pathsToPull=()
    while [[ $# -gt 0 ]]; do
        local arg=$1; shift
        case $arg in
            --) break ;;
            *) pathsToPull+=("$arg")
        esac
    done

    # run command if any were given (after a dash-dash)
    local exitStatus=0
    [[ $# -eq 0 ]] || remocon.run "$@" || exitStatus=$?

    # then get files
    set --; [[ ${#pathsToPull[@]} -eq 0 ]] || set -- "${pathsToPull[@]}"
    remocon.get "$@" || exitStatus=$?

    return $exitStatus
}

# put and use a new TMUX window to record given command's execution
remocon.rec() {
    remocon.put

    if [[ $# -gt 0 ]]; then
        info "⏺ [$remote_host:$remote_workdir] recording a new TMUX window with: $(@q "$@")"
        set -- "tmux send-keys C-L $(@q "$(@q "$@")") Enter"
        ! in_full_tty || warning "[$remote_host:$remote_workdir] attaching to the new TMUX window (TIP: append \` |:\` to command-line to prevent this)"
    elif in_full_tty; then
        # in a tty, provide a handy way to create a new window in the same TMUX session
        info "⏺ [$remote_host:$remote_workdir] recording a new TMUX window for an interactive session"
    else
        error 'Missing command. remocon rec can attach to a new TMUX window in a tty, but requires a command otherwise.'
    fi

    # cd is better typed than relying on tmux's new-window/session -c option
    set -- "tmux send-keys $(@q "$(cmdsep=" && " cmdseq \
            "cd" \
            "mkdir -p $(@q "$remote_workdir")" \
            "cd $(@q "$remote_workdir")" \
            #
        )") Enter" "$@"

    # attach to the new tmux window when in a tty
    ! in_full_tty ||
        set -- "$@" 'tmux attach'

    # when interacting with tmux, doing it from a login shell may be slightly more desirable
    bash_opts+=(-l)

    _remocon_start_tmux_window() {
        [[ $(tmux list-sessions 2>/dev/null | wc -l) -gt 0 ]] || x tmux new-session -d
        x tmux new-window
    }
    eval "_remocon_rec_cmd() { $(cmdseq _remocon_start_tmux_window "${@/#/x }"); }"
    rbc "$remote_host:$remote_workdir" _remocon_rec_cmd _remocon_start_tmux_window
}


################################################################################
# dispatching sub-commands
remocon() {
    if ! [[ $# -gt 0 ]]; then
        if in_full_tty; then
            # in a tty, defaults to replicating and opening a new TMUX window or an interactive/login shell on remote
            if $remote_tmux; then
                set -- rec
            else
                set -- run
            fi
        else
            # otherwise, defaults to just replicating local git work tree to remote
            set -- put
        fi
    fi

    cmd=$1; shift
    handler="remocon.$cmd"
    type "$handler" &>/dev/null ||
        error "$cmd: No such command.  Command must be one of: set, put, run, get, prg, or rec"
    case $cmd in _*) ;; *) remocon._init ;; esac  # common prep for normal commands
    "$handler" "$@"
}

remocon "$@"
