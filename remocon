#!/usr/bin/env bash
# remocon -- run given command remotely, replicating local git work tree on a remote host, and downloading remote changes if needed
#
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2018-03-08
##
#   Copyright 2018 Jaeho Shin
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
##
set -euo pipefail

error()   { echo >&2 "📡 ‼️ " "$@"; false; }
warning() { echo >&2 "📡 ⚠️ " "$@"; }
info()    { echo >&2 "📡" "$@"; }

in_full_tty() { [[ -t 0 && -t 1 && -t 2 ]]; }

################################################################################

# a nimble/simple way to use bash -x itself to get single-quoted escapes instead of backslashes given by printf %q
@q() {
    local e
    e=$(PS4= bash --norc -xc ': "$@"' -- "$@" 2>&1)
    echo "${e:2}"
}
# a handy way to compose a shell script that consists of multiple commands in one shot
cmdseq() {
    local cmd
    for cmd; do
        [[ -n $cmd ]] || continue
        printf '%s; ' "$cmd"
    done
}
# a handy way to show what command is running
x() {
    (
        case ${1:-} in (builtin|command) shift;; esac
        echo "$PS4$(@q "$@")"
    ) >&2
    "$@"
}

mkdelegate() {
    : echo 'generates an executable file for delegating with extra options'
    : echo
    : echo 'mkdelegate FILE ABS_PATH_TO_COMMAND [OPTION...]'
    local file=$1; shift
    mkdir -p "$(dirname "$file")"
    local script=$(
        echo '#!/bin/sh'
        echo "$(@q exec "$@")" '"$@"'
    )
    diff -q <(echo "$script") "$file" &>/dev/null || echo "$script" >"$file"
    chmod +x "$file"
}

# run on given remote host:workdir given bash function, sending variable and function declarations
rbashfn() {
    local hostworkdir=$1; shift
    local fn=$1; shift
    case $hostworkdir in
        (*:*) host=${hostworkdir%%:*} workdir=${hostworkdir#*:};;
        (*) error "$hostworkdir: HOST[:PATH] required";;
    esac
    remote_host="$host" \
    run-remotely \
        ": FIXME remove this bogus first arg" \
        "set -eu" \
        "mkdir -p $(@q "$dir")" \
        "cd $(@q "$workdir")" \
        "PS4=$(@q "+ $hostworkdir$ ")" \
        "set -x" \
        "$(declare -p -f -- "$fn")" \
        "$([[ $# -eq 0 ]] || declare -f -- "$@")" \
        "$([[ $# -eq 0 ]] || declare -p -- "$@" # TODO exclude declare -F to suppress errors
        )" \
        "$fn"
}

# a handy way to patch remote
# See: https://github.com/netj/bpm/blob/master/plugin/git-helper
git-tether-remote() {
    (
    set -euo pipefail
    hostpath=$1; shift
    case $hostpath in
        (*:*) host=${hostpath%%:*} dir=${hostpath#*:};;
        (*) error "$hostpath: HOST[:PATH] required";;
    esac
    commit=$(git rev-parse HEAD)
    branch=$(git symbolic-ref --short HEAD)
    bash_remotely() {
        local script=$1; shift
        ssh "$host" "$(@q bash -euc "PS4='++ '; $script" "$@")"
    }
    git remote add remocon/remote "$host:$dir" 2>/dev/null ||
        git remote set-url remocon/remote "$host:$dir"
    git push -q -f remocon/remote HEAD:"$branch" 2>/dev/null || {
        _remocon_git_init() {
            # set -x
            [[ -e .git ]] || git init
            # lift some git config to allow push
            git config receive.denyCurrentBranch ignore
        }
        rbashfn "$hostpath" _remocon_git_init x @q
        x git push -f remocon/remote HEAD:"$branch"
    }
    # TODO transfer git config to destination
    git remote remove remocon/remote
    # bring destination to the current commit
    command-that-actually-rm-files-deleted-from-git-index-that-come-from() {
        local commit=$1; shift
        echo "comm -12 <(git ls-tree -r --name-only $(@q "$commit") | sort) <(git ls-files --others --exclude-standard | sort) | tr '\\n' '\\0' | xargs -0 rm -f"
    }
    bash_remotely "# set -x
        cd $(@q "$dir")
        branch=$(@q "$branch")
        commit=$(@q "$commit")
        # reverse any previous patch for tethering
        if [[ -s .git/tethered.patch ]]; then
            git apply --binary -R <.git/tethered.patch || git stash
            mv -f .git/tethered.patch{,~}
        fi
        if git rev-parse HEAD &>/dev/null; then
            # preserve any outstanding/untethered changes
            git diff --quiet --exit-code HEAD -- || git stash
            # make sure we're on the tethered branch and commit
            [[ \$(git symbolic-ref --short HEAD) = \$branch ]] || git checkout -f \$branch --
        else
            # no branch was checked out before
            git checkout -f \$branch --
        fi
        git reset --hard \$commit
        $(command-that-actually-rm-files-deleted-from-git-index-that-come-from "HEAD@{1}")  # (necessary as git-reset does not always handle delete files cleanly)
    "
    # send staged and unstaged changes
    git diff --full-index --binary HEAD |
    bash_remotely "cat >$(@q "$dir")/.git/tethered.patch"
    bash_remotely "# set -x
        cd $(@q "$dir")
        # with the same outstanding changes on top of the current commit
        ! [[ -s .git/tethered.patch ]] || git apply --binary --apply --stat --cached <.git/tethered.patch
        # (relying on git-checkout from current git index takes care of a lot, such as permissions, symlinks)
        git checkout --quiet .
        # (however, git-checkout does not handle deleted files nicely, so ensuring any files in HEAD that fell into --others are removed)
        $(command-that-actually-rm-files-deleted-from-git-index-that-come-from "HEAD")
        "
    # replicate staged changes AKA .git/index
    git diff --full-index --binary --cached |
    bash_remotely "cat >$(@q "$dir")/.git/tethered-index.patch"
    bash_remotely "# set -x
        cd $(@q "$dir")
        git reset --quiet  # (resetting the git index first to apply the patch for locally staged changes)
        ! [[ -s .git/tethered-index.patch ]] || git apply --binary --apply --cached <.git/tethered-index.patch
        "
    )
}

# defaults to not running things remotely
remote_host=localhost
remote_workdir=
: ${remote_tmux:=true}
ssh_opts=(
)
bash_opts=(
    bash
)
# shorthand to run given sequence of commands remotely
run-remotely() {
    local script=$1; shift
    if in_full_tty; then
        # when I/O/Err is a fully functional terminal
        ssh_opts+=(-t)   # ask ssh for tty
        bash_opts+=(-i)  # ask bash for an interactive shell
    fi
    x ssh "$remote_host" \
        "${ssh_opts[@]:---}" \
        "$(@q "${bash_opts[@]}" -c "$(cmdseq "$@")")"
}

################################################################################
# common prep and sub-commands

# TODO turn below into a function and call it from bottom
{
    # make sure we're in a git work tree
    $(git rev-parse --is-inside-work-tree) ||
        error "$PWD: Not inside a git work tree"

    # TODO migrate remocon.conf to git config
    # find closest .remocon.conf
    conf=$(
        until [[ $PWD = / || -e .remocon.conf ]]; do cd ..; done
        ! [[ -e .remocon.conf ]] || echo "$PWD"/.remocon.conf
    )

    # load from .remocon.conf but let what's in environ override
    ! declare -p remote &>/dev/null || remote_override=$remote
    ! [[ -e "$conf" ]] || source "$conf"
    ! declare -p remote_override &>/dev/null || remote=$remote_override
    # TODO let all remote_* vars to be overriddable by env vars, e.g., remote_tmux

    # require remote= to be set
    [[ -n ${remote:=} || ${1:-} = set ]] || error "No remote configured. Please run: remocon set"

    # parse remote
    remote_host=${remote%%:*}
    remote_repo_root=${remote#$remote_host}
    remote_repo_root=${remote_repo_root#:}

    # use local git work tree's basename and keep it under given remote_repo_root dir
    remote_repo=${remote_repo_root:+$remote_repo_root/}$(basename "$(git rev-parse --show-toplevel)")

    # determine remote workdir based on where in the git repo we're in
    local_path_within_git=$(git rev-parse --show-prefix)
    remote_workdir="${remote_repo}/${local_path_within_git#/}"

    # override ssh options/config
    sshBoosterOpts=(
        # share an ssh connection across invocation
        -o ControlMaster=auto
        -o ControlPath="/tmp/remocon-$USER.sock-%r@%h:%p"
        -o ControlPersist=600
        # forward agent
        -A
    )
    sshBoosterRoot=~/.cache/remocon/ssh
    for cmd in scp ssh; do
        mkdelegate "$sshBoosterRoot"/bin/"$cmd" "$(type -p "$cmd")" "${sshBoosterOpts[@]}"
    done
    PATH="$sshBoosterRoot"/bin:"$PATH"
} </dev/null >&2

# break the ssh connection when interrupted, e.g., ControlPath can get stale
trap 'x ssh "$remote_host" -O stop' INT

# prints configured remote, inferred remote_repo root, remote_workdir
remocon.remote() { echo "$remote"; }
remocon.remote_repo() { echo "$remote_host:$remote_repo"; }
remocon.remote_workdir() { echo "$remote_host:$remote_workdir"; }

# set up ~/.remocon.conf
remocon.set() {
    local examples=$(echo \
        $'\n'"    user@example.org:tmp/repos       to put a clone of local git work tree 'foo' under 'tmp/repos/foo', or" \
        $'\n'"    example.org or user@example.org  to put all remote clones on the home dir." \
        #
    )
    if [[ $# -eq 0 ]] && in_full_tty; then
        info "Enter a remote host and path prefix to use, e.g.:$examples"
        read -p '>>> ' -r remote || true
    else
        [[ $# -gt 0 ]] || error "No USER@HOST[:PATH] specified as first argument, e.g.:$examples"
        local remote=$1; shift
    fi
    [[ -n $remote ]] || error "No remote specified"
    info "[$remote] ⚙️ setting ~/.remocon.conf"
    printf >>~/.remocon.conf 'remote=%q\n' "$remote"
}

# tether remote git repo to local one
remocon.put() {
    [[ $# -eq 0 ]] || error "Cannot put partial changes under given paths: $(@q "$@")"
    # TODO accept multiple remotes as args
    info "[$remote_host:$remote_repo/] 🛰 putting a replica of local git work tree on remote"
    git-tether-remote "$remote_host:$remote_repo"
} </dev/null >&2

# put and run given command on remote from the same workdir relative to the git top-level (AKA git prefix)
remocon.run() {
    remocon.put

    [[ $# -gt 0 ]] || set -- bash -il
    info "[$remote_host:$remote_workdir] ⚡️ running command: $(@q "$@")"

    case $remote_host in
        localhost)
            # just run given command when remote is local
            warning "[$remote_host] Not running remotely"
            x mkdir -p "$remote_workdir"
            x cd "$remote_workdir"
            x "$@"
            ;;

        *)
            run-remotely \
                'cd' \
                'set -eu' \
                "mkdir -p $(@q "$remote_workdir")" \
                "cd $(@q "$remote_workdir")" \
                "exec $(@q "$@")" \
                #
    esac
}

# get remote changes back to local
remocon.get() {
    [[ $# -gt 0 ]] || set -- .
    info "[$remote_host:$remote_workdir] 💎 getting remote files under $# paths: $(@q "$@")"
    # TODO use git in case rsync is not available?
    x rsync \
        --verbose \
        --archive \
        --hard-links \
        --omit-dir-times \
        --checksum \
        --copy-unsafe-links \
        --exclude=.git \
        --relative --rsync-path="$(printf 'cd; mkdir -p %q && cd %q &>/dev/null && rsync' "$remote_workdir" "$remote_workdir")" \
        "$remote_host":"$(@q "$@")" .
} </dev/null >&2

# programming round-trip mode (put-run-get)
remocon.prg() {
    # find which paths to get from given args
    # (NOTE path list can be terminated by a double-dash `--` to delinate the command to run)
    local pathsToPull=
    pathsToPull=()
    while [[ $# -gt 0 ]]; do
        local arg=$1; shift
        case $arg in
            --) break ;;
            *) pathsToPull+=("$arg")
        esac
    done

    # run command if any were given (after a dash-dash)
    local exitStatus=0
    [[ $# -eq 0 ]] || remocon.run "$@" || exitStatus=$?

    # then get files
    set --; [[ ${#pathsToPull[@]} -eq 0 ]] || set -- "${pathsToPull[@]}"
    remocon.get "$@" || exitStatus=$?

    return $exitStatus
}

# put and use a new TMUX window to record given command's execution
remocon.rec() {
    remocon.put

    if [[ $# -gt 0 ]]; then
        info "[$remote_host:$remote_workdir] ✨ recording a new TMUX window with: $(@q "$@")"
        set -- "tmux send-keys C-L $(@q "$(@q "$@")") Enter"
        ! in_full_tty || warning "[$remote_host:$remote_workdir] attaching to the new TMUX window (TIP: append \` |:\` to command-line to prevent this)"
    elif in_full_tty; then
        # in a tty, provide a handy way to create a new window in the same TMUX session
        info "[$remote_host:$remote_workdir] ✨ recording a new TMUX window for an interactive session"
    else
        error 'Missing command. remocon rec can attach to a new TMUX window in a tty, but requires a command otherwise.'
    fi

    # cd is better typed than relying on tmux's new-window/session -c option
    set -- "tmux send-keys $(@q "cd; mkdir -p $(@q "$remote_workdir") && cd $(@q "$remote_workdir")") Enter" "$@"

    # attach to the new tmux window when in a tty
    ! in_full_tty ||
        set -- "$@" 'tmux attach'

    # when interacting with tmux, doing it from a login shell may be slightly more desirable
    bash_opts+=(-l)

    run-remotely \
        'tmux start-server' \
        'if [[ $(tmux list-sessions | wc -l) -eq 0 ]]' \
        "then tmux new-session -d" \
        "else tmux new-window    " \
        'fi' \
        "$@" \
        #
}

################################################################################
# dispatch sub-commands

if ! [[ $# -gt 0 ]]; then
    if in_full_tty; then
        # in a tty, defaults to replicating and opening a new TMUX window or an interactive/login shell on remote
        if $remote_tmux; then
            set -- rec
        else
            set -- run
        fi
    else
        # otherwise, defaults to just replicating local git work tree to remote
        set -- put
    fi
fi

cmd=$1; shift
handler="remocon.$cmd"
type "$handler" &>/dev/null ||
    error "$cmd: No such command.  Command must be one of: set, put, run, get, prg, or rec"
"$handler" "$@"
