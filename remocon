#!/usr/bin/env bash
# remocon -- run given command remotely, tethering a workdir on a remote host to local git repo
#
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2018-03-08
##
set -euo pipefail

error() { echo >&2 "$@"; false; }
warning() { echo >&2 "$@"; }
info() { echo >&2 "$@"; }

# make sure we're in a git work tree
$(git rev-parse --is-inside-work-tree) ||
    error "$PWD: Not inside a git work tree"

################################################################################
# a nimble/simple way to use bash -x itself to get single-quoted escapes instead of backslashes given by printf %q
@q() {
    local e
    e=$(PS4= bash --norc -xc ': "$@"' -- "$@" 2>&1)
    echo "${e:2}"
}
# a handy way to show what command is running
x() {
    (
        case ${1:-} in (builtin|command) shift;; esac
        echo "$PS4$(@q "$@")"
    ) >&2
    "$@"
}

mkdelegate() {
    : echo 'generates an executable file for delegating with extra options'
    : echo
    : echo 'mkdelegate FILE ABS_PATH_TO_COMMAND [OPTION...]'
    local file=$1; shift
    mkdir -p "$(dirname "$file")"
    local script=$(
        echo '#!/bin/sh'
        echo "$(@q exec "$@")" '"$@"'
    )
    diff -q <(echo "$script") "$file" &>/dev/null || echo "$script" >"$file"
    chmod +x "$file"
}

# a handy way to patch remote
# See: https://github.com/netj/bpm/blob/master/plugin/git-helper
git-tether-remote() {
    (
    set -euo pipefail
    hostpath=$1; shift
    case $hostpath in
        (*:*) host=${hostpath%%:*} dir=${hostpath#*:};;
        (*) error "$hostpath: host:path required";;
    esac
    commit=$(git rev-parse HEAD)
    branch=$(git symbolic-ref --short HEAD)
    git remote add remocon/remote "$host:$dir" 2>/dev/null ||
        git remote set-url remocon/remote "$host:$dir"
    git push -q -f remocon/remote HEAD:"$branch" 2>/dev/null || {
        ssh "$host" "
            set -eu; PS4='++ '; # set -x
            mkdir -p $(@q "$dir")
            cd $(@q "$dir")
            [[ -e .git ]] || git init
            # lift some git config to allow push
            git config receive.denyCurrentBranch ignore
        "
        git push -f remocon/remote HEAD:"$branch"
    }
    git remote remove remocon/remote
    # bring destination to the current commit
    ssh "$host" "set -eu; PS4='++ '; # set -x
        cd $(@q "$dir")
        branch=$(@q "$branch")
        commit=$(@q "$commit")
        # reverse any previous patch for tethering
        if [[ -e .git/tethered.patch ]]; then
            git apply --binary -R <.git/tethered.patch || git stash
            mv -f .git/tethered.patch{,~}
        fi
        if git rev-parse HEAD &>/dev/null; then
            # preserve any outstanding/untethered changes
            git diff --quiet --exit-code HEAD -- || git stash
            # make sure we're on the tethered branch and commit
            [[ \$(git symbolic-ref --short HEAD) = \$branch ]] || git checkout -f \$branch --
        else
            git checkout -f \$branch --
        fi
        git reset --hard \$commit
    "
    # send staged and unstaged changes
    git diff --full-index --binary HEAD |
    ssh "$host" "cat >$(@q "$dir")/.git/tethered.patch"
    ssh "$host" "set -eu; PS4='++ '; # set -x
        cd $(@q "$dir")
        # with the same outstanding changes on top of the current commit
        ! [[ -s .git/tethered.patch ]] || git apply --binary --apply --stat --cached <.git/tethered.patch
        git checkout --quiet .
        git reset --quiet
        "
    # replicate staged changes AKA .git/index
    git diff --full-index --binary --cached |
    ssh "$host" "cat >$(@q "$dir")/.git/tethered-index.patch"
    ssh "$host" "set -eu; PS4='++ '; # set -x
        cd $(@q "$dir")
        ! [[ -s .git/tethered-index.patch ]] || git apply --binary --apply --cached <.git/tethered-index.patch
        "
    )
}
################################################################################

{
# find closest .remocon.conf
conf=$(
    until [[ $PWD = / || -e .remocon.conf ]]; do cd ..; done
    ! [[ -e .remocon.conf ]] || echo "$PWD"/.remocon.conf
)

# defaults to not running things remotely
ssh_opts=(
)
bash_opts=(
    bash
)

! [[ -e "$conf" ]] || source "$conf"
: ${remote:=localhost}

# parse remote
remote_host=${remote%%:*}
remote_repo_root=${remote#$remote_host}
remote_repo_root=${remote_repo_root#:}

# no-op when remote is local
case $remote_host in localhost)
    # not remote, just run given command
    info "remote=$remote: Not running remotely"
    x "$@"
    exit $?
esac

# use local git work tree's basename and keep it under given remote_repo_root dir
remote_repo=${remote_repo_root:+$remote_repo_root/}$(basename "$(git rev-parse --show-toplevel)")

# determine remote workdir based on where in the git repo we're in
local_path_within_git=$(git rev-parse --show-prefix)
remote_workdir="${remote_repo}/${local_path_within_git#/}"

# override ssh options/config
sshBoosterOpts=(
    # share an ssh connection across invocation
    -o ControlMaster=auto
    -o ControlPath="/tmp/remocon-$USER.sock-%r@%h:%p"
    -o ControlPersist=600
)
sshBoosterRoot=~/.cache/remocon/ssh
for cmd in scp ssh; do
    mkdelegate "$sshBoosterRoot"/bin/"$cmd" "$(type -p "$cmd")" "${sshBoosterOpts[@]}"
done
PATH="$sshBoosterRoot"/bin:"$PATH"

# tether remote git repo to local one
info "remote=$remote: deploying local git work tree to $remote_host:$remote_repo"
git-tether-remote "$remote_host:$remote_repo"
} </dev/null >&2

# and run given command from the same workdir
info "remote=$remote: running command from $remote_host:$remote_workdir"
if [[ -t 0 && -t 1 && -t 2 ]]; then
    # when I/O/Err is a fully functional terminal
    ssh_opts+=(-t)   # ask ssh for tty
    bash_opts+=(-i)  # ask bash for an interactive shell
fi
x ssh "$remote_host" \
    "${ssh_opts[@]:---}" \
    "$(@q "${bash_opts[@]}" -c "cd $(@q "$remote_workdir") && exec $(@q "$@")")"